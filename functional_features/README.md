# 함수형 언어의 특성들: 반복자들과 클로저들

러스트의 디자인은 많은 기존 언어들과 기술들에서 영감을 얻었으며, 중요한 영향 중 하나는 *함수형 프로그래밍*이다. 함수형 스타일의 프로그래밍은 자주 함수를 값처럼 인자로 넘기는 것, 다른 함수들에서 결괏값으로 함수들을 돌려주는 것, 나중에 실행하기 위해 함수를 변수에 할당하는 것 등을 포함한다.

이번 장에서는 다룰 것은 밑과 같다.
- 클로저들, 변수에 저장할 수 있는 함수와 유사한 구조
- 반복자들, 일련의 요소를 처리할 수 있는 방법
- 이 두가지 특성들을 사용해서 I/O 프로젝트를 향상시킬 수 있는 방법

## 클로저: 환경을 캡처할 수 있는 익명 함수

러스트의 *클로저*는 변수에 저장하거나 *다른 함수에 인자로 넘길 수 있는 익명 함수* 이다. 한 곳에서 클로저를 만들고 다른 문맥에서 그것을 평가하기 위해 호출할 수 있다. 함수와 다르게 클로저는 그들이 호출되는 스코프로부터 변수들을 캡처할 수 있다. 이 클로저 특성이 코드 재사용과 동작 사용자 정의를 어떤 식으로 허용하는지 예를 들어 보여줄 것이다.

### 클로저로 행위를 추상화 하기

클로저를 나중에 실행하기 위해 저장하는 것이 유용한 상황에 대한 예제로 작업해 보다/

<코드: main.rs 참고>

클로저는 `fn` 함수처럼 파라미터나 반환값의 타입을 명시할 것을 요구하지 않는다. 타입 어노테이션은 사용자에게 노출되는 명시적인 인터페이스의 일부이기 때문에 함수에 필요하다. 이 인터페이스를 엄격하게 정의하는 것은 함수가 어떤 타입의 값을 사용하고 반환하는지에 대해 모두가 합의 한다는 것을 보장하는데 중요하다. 그러나 클로저는 이와 같이 노출된 인터페이스에 사용되지 않는다. 변수에 저장되고 이름없이 우리의 라이브러리 사용자들에게 노출되지 않고 사용된다.

```rust
let example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5)l
```
정의에 타입 어노테이션을 추가하지 않고 클로저를 두 번 호출하는데, 첫번째는 `String`을 인자로 사용하고 두번째는 `u32`를 사용한다면 에러가 발생한다.

```rust
error[E0308]: mismatched types
 --> src/main.rs
  |
  | let n = example_closure(5);
  |                         ^ expected struct `std::string::String`, found
  integral variable
  |
  = note: expected type `std::string::String`
             found type `{integer}`
```

처음 String 값으로 example_closure 을 호출하면, 컴파일러는 x 의 타입과 클로저의 반환 타입을 String 으로 추론한다. 이 타입들은 그다음에는 example_closure 에 있는 클로저에 고정되고, 같은 클로저를 다른 타입으로 사용하려고 할 때 타입 에러를 얻게 된다.

### 제너릭 파라미터와 Fn 트레잇을 사용하여 클로저 저장하기

우리는 클로저와 클로저를 호출한 결과값을 갖고 있는 구조체를 만들 수 있다. 그 구조체는 결과값을 필요로 할 때만 클로저를 호출 할 것이며, 결과값을 캐시에 저장해 두어 우리의 나머지 코드에서 결과를 저장하고 재사용 하지 않아도 되도록 할 것이다. 이 패턴을 메모이제이션(memoization) 혹은 *지연 평가(lazy evaluation)* 로 알고 있을 것이다.