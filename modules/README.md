# 모듈을 사용하여 코드를 재사용하고 조직화하기

러스트로 프로그램을 작성하기 시작했을 때, 처음 코드는 오로지 `main` 함수 안에만 있을지도 모르겠다. 하지만 코드가 커짐에 따라서, 재사용 및 더 나은 조직화를 위하여 결국 어떤 기능을 다른 함수로 이동시킨다.

코드를 더 작은 덩어리로 쪼갬으로써, 각각의 덩어리들은 개별적으로 이해하기 더 수월해진다. 하지만 함수가 너무 많으면 러스트는 조직화된 방식으로 코드의 재사용을 할 수 있게 해주는 모듈(module) 시스템을 갖추고 있다.

코드 몇 줄을 함수로 추출하는 것과 같은 방식으로, 함수 (혹은 구조체나 열거형 같은 다른 코드들)를 다른 모듈로 뽑아낼 수 있으며, 여러분은 이것들의 정의가 모듈의 바깥쪽에서 볼 수 있도록 하거나(public) 혹은 보이지 않도록 (private) 선택할 수 있다. 

- `mod` 키워드는 새로운 모듈을 선언한다. 모듈 내의 코드는 이 선언 바로 뒤에 중괄호로 묶여서 따라오거나 다른 파일에 놓일 수 있다.
- 기본적으로, 함수, 타입, 상수 그리고 모듈은 private이다. `pub` 키워드가 어떤 아이템을 public하게 만들어줘서 이것이 네임스페이스 바깥쪽에서도 볼 수 있도록 한다.
- `use` 키워드는 모듈이나 모듈 내의 정의들을 스코프 안으로 가져와서 이들을 더 쉽게 참조할 수 있도록 한다.

## mod와 파일 시스템

먼저 카고를 이용하여 새로운 프로젝트를 만드는 것으로 모듈 예제를 시작하려고 하는데, 바이너리 크레이트(crate)을 만드는 대신에 라이브러리 크레이트를 만들 것이다. 여기서 라이브러리 크레이트란 다른 사람들이 자신들의 프로젝트에 디펜던시(dependency)로 추가할 수 있는 프로젝트를 말한다. 예를 들어, 2장의 `rand` 크레이트는 우리가 추리 게임 프로젝트에서 디펜던시로 사용했던 라이브러리 크레이트이다.

우리는 몇가지 일반적인 네트워크 기능을 제공하는 라이브러리의 뼈대를 만들 것이다. 여기서는 모듈들과 함수들의 조직화에 집중할 것이고, 함수의 본체에 어떤 코드가 들어가야 하는지는 신경쓰지 않겠다. 이 라이브러리를 `communicator`라고 부르겠다. 라이브버리를 만들기 위해서는 `--bin` 대신 `--lib`를 옵션을 넘긴다.

`lib.rs` 안의 코드를 보면

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}

```

위와 같은 코드를 찾을 수 있다.

카고는 우리가 만든 라이브러리의 작성 시작을 돕기 위해 빈 테스트를 만드는데, 이는 `--bin` 옵션을 사용했을 때 "Hello, world!" 바이너리를 만들어준 것과 사뭇 다르다.

`main.rs` 파일이 없기 때문에 `cargo run` 커맨드로 카고가 실행할 것이 없다. 따라서, 여기서는 라이브러리 크레이트의 코드를 컴파일 하기 위해 `cargo build` 를 사용할 것이다.

### 모듈 정의

우리의 `communicator` 네트워크 라이브러리를 위해서, 먼저 `connect`라는 이름의 함수가 정의되어 있는 `network`라는 이름의 모듈을 정의해보겠다. 러스트 내 모듈 정의는 모두 `mod`로 시작된다. 

