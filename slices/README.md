소유권을 갖지 않는 또다른 데이터 타입은 *슬라이스* 이다. 슬라이스는 컬렉션(collection) 전체가 아닌 컬렉션의 연속된 일련의 요소들을 참조할 수 있게 한다.

여기 작은 프로그래밍 문제가 있다. 스트링을 입력 받아 그 스트링에서 찾은 첫번째 단어를 반환하는 함수를 작성해보자. 만일 함수가 공백문제를 찾지 못한다면, 이는 전체 스트링이 한 단어라는 의미이고, 이때는 전체 스트링이 반환되어야 한다.

이 함수의 시그니처(signature)에 대해 생각해보자.

```rust
fn first_word(s: &String) -> ?
```

이 함수 `first_word`는 `&String`을 파라미터로 갖는다. 우리는 소유권을 원하지 않으므로, 이렇게 해도 좋다. 하지만 우리는 스트링의 *일부* 에 대해 표현할 방법이 없다. 하지만 단어의 끝부분의 인덱스를 반환할 수는 있다.

```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }
    
    s.len()
}
```
위 코드는 `String` 파라미터의 바이트 인덱스 값을 반환하는 `first_word` 함수이다.

위 코드는 입력된 `String`을 요소별로 보면서 그 값이 공백인지 확인할 필요가 있기 때문에, `String`은 `as_bytes` 메소드를 이용하여 바이트 배열로 변환된다.

```rust
let bytes = s.as_bytes();
```

다음으로, `iter` 메소드를 이용하여 바이트 배열의 반복자(iterator)을 생성한다.

```rust
for (i, &item) in bytes.iter().enumerate()
```

`iter`은 컬렉션의 각 요소를 반환하는 함수이며, `enumerate`은 `iter`의 결과값을 직접 반환하는 대신 이를 감싸서 튜플의 일부로 만들어 반환한다. 반환된 튜플의 첫번째 요소는 인덱스이며, 두번째 요소는 요소에 대한 참조값이다. 이는 우리 스스로 인덱스를 계산하는 것보다 조금 더 편리하다.

`enumerate` 메소드가 튜플을 반환하기 때문에, 우리는 이 튜플을 해체하기 위해 패턴을 사용할 수 있다. 따라서 `for` 루프 내에서, `i`는 튜플 내의 인덱스에 대응하고 `&item` 은 튜플 내의 한 바이트에 대응하는 패턴을 기술한 것이다. `.iter().enumerate()`의 요소에 대한 참조자를 갖는 것이므로, `&`을 패턴 내에 사용했다. 

우리는 바이트 리터럴 문법을 이용하여 공백 문자를 나타내는 바이트를 찾는다. 공백 문자를 찾았다면, 이 위치를 반환한다. 그렇지 않으면 `s.len()`을 통해 스트링의 길이값을 반환한다.

```rust
if item == 'b' {
    return i;
}
s.len()
```
이제 우리에게 스트링의 첫번째 단어와 끝부분의 인덱스를 찾아낼 방법이 생겼다. `usize`를 그대로 반환하고 있지만, 이는 `&string`의 내용물 내에서만 의미가 있다. 바꿔 말하면, 이것이 `String`으로부터 분리되어 있는 숫자이기 때문에, 이것이 나중에도 여전히 유효한지를 보장할 길이 없다. 

<코드: main.rs 1> 의 코드는 아무런 오류 없이 컴파일되고, `s.clear()`를 로출한 뒤 `word`를 사용한다 해도 역시 컴파일될 것이다. `word`는 `s`의 상태와 전혀 연결되어 있지 않으므로 `word`는 여전히 값 `5`를 담고 있다. 우리는 첫번째 단어를 추출하고자 하기 위해 `s`와 값 `5`를 사용할 수 있지만, `word`에 `5`를 저장한 뒤 `s`의 내용물이 변경되었기 때문에 이러한 사용은 버그가 될 것이다.

`word`의 인덱스가 `s`의 데이터와 싱크가 안맞을 것을 걱정하는 건 지겹고 쉽게 발생할 수 있는 오류이다. 이러한 인덱스들을 관리하는 것은 우리가 `second_word` 함수를 작성했을 때 더더욱 다루기 어려워진다.

```rust
fn second_word(s: &String) -> (usize, usize) {}
```

이제 우리는 시작, 그리고 끝 인덱스를 추적하고 있고, 특정 상태에 있는 데이터로부터 계산되었지만 그 상태에 전혀 묶이지 않은 더 많은 값들을 갖게 된다. 

### 스트링 슬라이스

*스트링 슬라이스*는 `String`의 일부분에 대한 참조자다.

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```
이는 전체 `String`의 참조자를 갖는 것과 비슷하지만, 추가적으로 `[0..5]` 라는 코드가 붙어 있다. 전체 `String`에 대한 참조자 보다는, `String`의 일부분에 대한 참조자이다. `start..end` 구문은 `start` 부터 시작하여 `end`를 포함하지 않는 연속된 범위를 기술한다.

우리는 대괄호 내에 `[starting_index..ending_index]` 를 특정한 범위를 이용하여 슬라이스를 만들 수 있는데, 여기서 `starting_index`는 슬라이스에 포함되는 첫번째 위치이고 `ending_index`는 슬라이스에 포함될 마지막 위치보다 1을 더한 값이다. 내부적으로 슬라이스 데이터 구조는 시작 위치와 슬라이스의 길이를 저장하는데, 이 길이 값은 `ending_index`에서 `starting_index`를 뻰 값이다. 따라서 `let world = &[6..1];` 의 경우 `world`는 `s`의 6번째 바이트를 가리키고 있는 포인터와 길이값 5를 갖고 있는 슬라이스가 될 것이다. 

![image](https://user-images.githubusercontent.com/73830753/166405234-3a3593dd-3e8a-4da4-90d0-26476a60a858.png)

위는 `String`의 일부를 참조한 스트링 슬라이스이다.

러스트의 `..` 범위 문법을 사용하여, 여러분이 만일 첫번째 인덱스(0)에서부터 시작하길 원한다면, 두 개의 마침표 전의 값은 생략할 수 있다. 다시 말하면, 아래 두 줄은 동일한 표현이다.

```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```

비슷한 이치로, 만일 여러분의 슬라이스가 `String`의 마지막 바이트까지 포함한다면, 여러분은 끝의 숫자를 생략할 수 있다. 이는 아래 두 줄의 표현이 동일하다는 의미이다.

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```

여러분은 또한 전체 스트링의 슬라이스를 만들기 위해 양쪽 값을 모두 생략 할 수 있다. 따라서 아래 두 줄의 표현은 동일하다.

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```
"스트링 슬라이스"를 나타내는 타입은 `&str` 로 쓴다.

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

