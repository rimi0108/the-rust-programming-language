## 메소드 문법

메소드(method)는 함수와 유사하다. 이들은 `fn` 키워드와 이름을 가지고 선언되고, 파라미터와 반환 값을 가지고 있으며, 다른 어딘가로부터 호출되었을때 실행될 어떤 코드를 담고 있다, 하지만 메소드는 함수와는 달리 구조체의 내용 안에 정의되며 (혹은 열거형이나 트레잇 객체 안에 정의된다) 첫번째 파라미터가 언제나 `self` 인데, 이는 메소드가 호출되고 있는 구조체의 인스턴스를 나타낸다.

### 메소드 정의하기

<main.rs 의 코드 1 참조>

`Rectangle`의 내용 안에 함수를 정의하기 위해서, `impl` (구현: implementation) 블록을 시작한다. 그 다음 `area` 함수를 `impl` 중괄호 안으로 옮기고 시그니처 및 본체 내의 모든 곳에 있는 첫번째 파라미터 (지금의 경우에는 유일한 파라미터)를 `self`로 변경시킨다. 우리가 `area` 함수를 호출하고 여기에 `rect1`을 인자로 넘기고 있는 `main` 함수에서는, 이 대신 `Rectangle` 인스턴스 상의 `area` 메소드를 호출하기 위해서 메소드 문법(method syntax)를 이용 할 수 있다. 메소드 문법은 인스턴스 다음에 위치한다. 점을 추가하고 그 뒤를 이어 메소드 이름, 괄호, 인자들이 따라온다.

`area`의 시그니처 안에는, `rectangle: &Rectangle` 대신 `&self`가 사용되었는데 이는 메소드가 `impl Rectangle` 내용물 안에 위치하고 있어 러스트가 `self`의 타입이 `Rectangle` 이라는 사실을 알 수 있기 때문이다. 우리가 `&Rectangle`이라고 썼던 것처럼, `self` 앞에도 여전히 `&`를 사용할 필요가 있다. 메소드는 `self`의 소유권을 가져갈 수도, 여기서처럼 `self`를 변경 불가능하게 빌릴 수도, 혹은 다른 파라미터와 비슷하게 변경이 가능하도록 빌려올 수도 있다.

여기서는 함수 버전에서 `&Rectangle`을 이용한 것과 같은 이유로 `&self`를 택했다. 우리는 소유권을 가져오는 것을 원하지 않으며, 다만 구조체 내의 데이터를 읽기만 하고, 쓰고 싶지는 않다. 만일 그 메소드가 동작하는 과정에서 메소드 호출에 사용된 인스턴스가 변하기를 원했다면, 첫번째 파라미터로 `&mut self`를 썼을 것이다. 그냥 `self`를 첫번째 파라미터로 사용하여 인스턴스의 소유권을 가져오는 메소드를 작성하는 것은 드물다. 이러한 테크닉은 보통 해당 메소드가 `self` 을 다른 무언가로 변형시키고 이 변형 이후에 호출하는 측에서 원본 인스턴스를 사용하는 것을 막고 싶을 때 종종 쓰인다.

함수 대신 메소드를 이용하면 생기는 주요 이점은, 메소드 문법을 이용하여 모든 메소드 시그니처 내에서마다 `self`를 반복하여 타이핑하지 않아도 된다는 점과 더불어, 조직화에 대한 점이다. 우리 코드를 향후 사용할 사람들이 우리가 제공하는 라이브러리 내의 다양한 곳에서 `Rectangle`이 사용 가능한 지점을 찾도록 하는 것보다 하나의 `impl` 블록 내에 해당 타입의 인스턴스로 할 수 있는 모든 것을 모아두었다.

### 더 많은 파라미터를 가진 메소드

`Rectangle` 구조체의 두번째 메소드를 구현하여 메소드 사용법을 연습해보자. 이번에는 `Rectangle`의 인스턴스가 다른 `Rectangle`의 인스턴스를 가져와서 이 두번째 `Rectangle`이 `self`안에 완전히 안에 들어갈 수 있다면 `true`를 반환하고, 그렇지 않으면 `false`를 반환하고 싶어한다. 