## 참조자(References)와 빌림(Borrowing)

앞 절의 마지막에 등장한 튜플을 이용하는 이슈는 `String` 을 호출하는 함수 쪽으로 반환함으로써 `calculate_length` 를 호출한 이후에도 여전히 `String`을 이용할 수 있도록 하는 것인데, 그 이유는 `String`이 `calculate_length` 안 쪽으로 이동되었기 때문이다.

여기 값의 소유권을 넘기는 대신 개체에 대한 참조자(reference)를 인자로 사용하는 `calculate_length` 함수를 정의하고 이용하는 방법이 있다.

<코드: main.rs 1 참조> 

첫번째로, 변수 선언부와 함수 반환값에 있던 튜플 코드가 모두 없어진 것이 주목하라. 두번째로, `calculate_length` 함수에 `&s1`를 넘기고, 함수의 정의 부분에는 `String`이 아니라 `&String`을 이용했다는 점을 기억하라.

이 엠퍼센드(&) 기호가 참조자이며, 이는 여러분이 어떤 값을 소유권을 넘기지 않고 참조할 수 있도록 해준다. 

함수 호출 부분을 좀 더 자세히 보자

```rust
let s1 = String::from("hello");

let len = calculate_length(&s1);
```

`&s1` 문법은 우리가 `s1`의 값을 참조하지만 소유하지는 않는 참조자를 생성하도록 해준다. 소유권을 갖고 있지는 않기 때문에, 이 참조자가 가르키는 값은 참조자가 스코프 밖으로 벗어났을 때도 메모리가 반납되지 않을 것이다.

비슷한 이치로, 함수 시그니처도 `&`를 사용하여 인자 `s`의 타입이 참조자라는 것을 나타내고 있다.

```rust
fn calculate_length(s: &String) -> usize { // s는 String의 참조자이다.
    s.len()
} // 여기서 s는 스코프 밖으로 벗어났다. 하지만 가리키고 있는 값에 대한 소유권이 없기 때문에
  // 아무런 일도 발생하지 않는다.
```

변수 `s`가 유효한 스코프는 여느 함수의 파라미터의 스코프와 동일하지만, 소유권을 갖고 있지 않으므로 이 참조자가 스코프 밖으로 벗어났을 때 참조자가 가리키고 있는 값은 버리지 않는다. 또한 실제 값 대신 참조자를 파라미터로 갖고 있는 함수는 소유권을 갖고 있지 않기 때문에 소유권을 되돌려주기 위해 값을 다시 반환할 필요도 없다는 뜻이 된다.

함수의 파라미터로 참조자를 만드는 것을 *빌림*이라고 부른다. 실제 생활에서 어떤 사람이 뭔가를 소유하고 있다면, 여러분은 그것을 빌릴 수 있다. 하지만 용무가 끝났을 때는 그것을 돌려주어야 한다.

만일 우리가 빌린 무언가를 고치려고 시도한다면 작동이 되지 않을 것이다.

<코드: main.rs 2 참조>

변수가 기본적으로 불변인 것처럼, 참조자도 마찬가지이다. 우리가 참조하는 어떤 것을 변경하는 것은 허용되지 않는다.

### 가변 참조자(Mutable References)

`main.rs`의 코드를 살짝 바꾸면 오류를 고칠 수 있다. <코드: main.rs 3 참조>

먼저 `s`를 `mut`로 바꿔야 한다. 그리고 `&mut s`로 가변 참조자를 생성하고 `some_string: &mut String`으로 이 가변 참조자를 받아야 한다.

하지만 가변 참조자는 딱 한가지 큰 제한이 있다. 특정한 스코프 내에 특정한 데이터 조각에 대한 가변 참조자를 딱 하나만 만들 수 있다는 것이다. 아래 코드는 실패할 것이다.

```rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;
// cannot borrow `s` as mutable more than once at a time
```

이 제한 사항은 가변을 허용하긴 하지만 매우 통제된 방식으로 허용한다. 불편한 점도 있겠지만 이러한 제한이 가지는 이점은 바로 러스트가 컴파일 타임에 데이터 레이스(data race)를 방지할 수 있도록 해준다는 것이다.

*데이터 레이스*는 아래에 정리된 세 가지 동작이 발생했을 때 나타나는 특정한 레이스 조건이다.

1. 두 개 이상의 포인터가 동시에 같은 데이터가 접근한다.
2. 그 중 적어도 하나의 포인터가 데이터를 쓴다.
3. 데이터에 접근하는데 동기화를 하는 어떠한 메커니즘도 없다.

데이터 레이스는 정의되지 않는 동작을 일으키고 런타임에 이를 추적하고자 할 때는 이를 진단하고 고치기 어려울 수 있다. 러스트는 데이터 레이스가 발생할 수 있는 코드가 컴파일 조차 안되기 때문에 이 문제의 발생을 막아버린다.

항상 우리는 새로운 스코프를 만들기 위해 중괄호를 사용하는데, 이는 그저 *동시*에 만드는 것이 아니게 해줌으로써, 여러 개의 가변 참조자를 만들 수 있도록 해준다.

```rust
let mut s = String::from("hello");

{
  let r1 = *mut s;
} // 여기서 r1은 스코프 밖으로 벗어났으므로, 우리는 아무 문제 없이 새로운 참조자를 만들 수 있다.

let r2 = &mut s;
```

가변 참조자와 불변 참조자를 혼용할 경우에 대한 비슷한 규칙이 있다. 아래 코드는 컴파일 오류가 발생한다.

```rust 
let mut s = String::from("hello");

let r1 = &s;  // 문제 없음
let r2 = &s;  // 문제 없음
let r3 = &mut s; // 큰 문제 발생
// cannot borrow `s` as mutable because it is also borrowed as immutable
```
우리는 불변 참조자를 가지고 있을 동안에도 역시 가변 참조자를 만들 수 없다. 불변 참조자의 사용자는 사용 중인 동안에 값이 갑자기 바뀌리라 예상하지 않는다. 하지만 여러 개의 불변 참조자는 만들 수 있는데, 데이터를 그냥 읽기만 하는 것은 다른 것들이 그 데이터를 읽는 데에 어떠한 영향도 주지 못하기 때문이다.

### 댕글링 참조자(Dangling References)

포인터가 있는 언어에서는 자칫 잘못하면 *댕글링 포인터(danglind pointer)* 를 만들기 쉬운데, 댕글링 포인터란 어떤 메모리를 가리키는 포인터를 보존하는 동안, 그 메모리를 해제함으로써 다른 개체에게 사용하도록 줘버렸을 지도 모를 메모리를 참조하고 있는 포인터를 말한다. 러스트에서는 컴파일러가 모든 참조자들이 댕글링 참조자가 되지 않도록 보장해 준다. 만일 우리가 어떤 데이터의 참조자를 만들었다면, 컴파일러는 그 참조가가 스코프 밖으로 벗어나기 전에는 데이터가 스코프 밖으로 벗어나지 않을 것임을 확인해 줄 것이다.

<코드: main.rs 4 참조>

main.rs 4를 실행했을 때 뜨는 오류 메세지는 우리가 아직 다루지 못한 특정을 인용하고 있다. 바로 *라이프 타임(lifetime)* 

```
this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
(해석: 이 함수의 반환 타입은 빌린 값을 포함하고 있는데, 빌려온 실제 값은 없습니다.)
```

```rust
fn dangle() -> &String { // dangle은 String의 참조자를 반환합니다

    let s = String::from("hello"); // s는 새로운 String입니다

    &s // 우리는 String s의 참조자를 반환합니다.
} // 여기서 s는 스코프를 벗어나고 버려집니다. 이것의 메모리는 사라집니다.
  // 위험하군요!
```

`s`가 `dangle`안에서 만들어졌기 때문에, `dangle`의 코드가 끝이 나면 `s`는 할당 해제된다. 하지만 이 함수는 참조자를 반환하려고 했다. 이는 곧 이 참조자가 어떤 무효화된 `String`을 가리키게 될 것이라는 뜻이다. 러스트는 이것을 막아준다. 여기서의 해법은 `String`을 직접 반환하는 것이다.

```rust
fn no_dangle() -> String {
  let s = String::from("hello");

  s
}
```

위 코드는 아무런 문제 없이 동작한다. 소유권이 밖으로 이동되었고, 아무것도 할당 해제되지 않는다.

### 참조자의 규칙

우리가 참조자에 대해 논의한 것들을 정리해 보자.

1. 어떠한 경우이든 간에, 여러분은 아래 둘 중 하나만 가질 수 있다.
- 하나의 가변 참조자
- 임의 개수의 불변 참조자들

2. 참조자는 항상 유효해야만 한다.

